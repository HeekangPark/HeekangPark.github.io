---
title: "ndarray"
order: 3
date: "2020-08-10"
---

NumPy에서는 모든 데이터를 다차원 객체 `ndarray`에 담아 처리한다. 빠른 처리 속도를 위해 `ndarray`에는 다음과 같은 제약조건이 있다.

- 선언될 때 크기가 정해진다. 이후 동적으로 크기를 바꿀 수 없다.[^1] → `shape` 속성
- 원소들은 모두 같은 데이터 타입을 갖는다. → `dtype` 속성

크기를 마음대로 늘리거나 줄일 수 있고, 다른 종류의 데이터들을 막 때려담을 수 있는 파이썬의 리스트와는 사뭇 다르다. 오히려 C언어의 배열과 더 유사하다.[^2]

[^1]: 배열의 크기를 바꾸고 싶다면 새로운 배열을 생성해야 한다.
[^2]: NumPy가 C언어로 구현되었다는 것을 생각하면 사실 당연한 것일 수도 있다.

이번 글에서는 NumPy가 사용하는 데이터 객체, `ndarray`에 대해서 알아보겠다.

# ndarray 객체의 속성

객체 `ndarray`는 다음과 같은 속성을 갖는다.

- `shape` : 배열의 크기.
- `dtype` : 배열 요소(element)들의 데이터 타입. 부호 있는 정수형 `np.int8`, `np.int16`, `np.int32`, `np.int64`, 부호 없는 정수형 `np.uint8`, `np.uint16`, `np.uint32`, `np.uint64`, 실수형 `np.float16`, `np.float32`, `np.float64`, 복소수형 `np.complex64`, `np.complex128`, 부울형 `np.bool` 등이 올 수 있다.[^3]

[^3]: 데이터 타입 뒤의 숫자들은 비트 수를 의미한다. 예를 들어 `np.int8`은 8비트(1바이트) 데이터 타입이고, `np.int64`는 64비트(8바이트) 데이터 타입이다.

예를 들어, 다음과 같은 2×2×3 배열 `x`가 주어졌다고 하자.

{% highlight python %}
x = np.arange(12).reshape(2, 2, 3)
# x = [[[ 0  1  2]
#       [ 3  4  5]]
#     
#      [[ 6  7  8]
#       [ 9 10 11]]]
{% endhighlight %}

이때 속성 `shape`는 다음과 같이 읽을 수 있다.

{% highlight python %}
print(x.shape)  # (2, 2, 3)
{% endhighlight %}

속성 `dtype`은 다음과 같이 읽을 수 있다.

{% highlight python %}
print(x.dtype)  # int64
{% endhighlight %}

기본적으로 한 번 생성된 `ndarray` 객체의 속성은 변경할 수 없다. 속성을 바꿔야 한다면 바꾸고 싶은 속성값으로 설정된 새로운 `ndarray` 객체를 만들어 기존 변수를 덮어씌워야 한다.

예를 들어 `x`의 `dtype` 속성을 바꾸고 싶다면, 다음과 같이 [`np.array()`](#kramdown_파이썬-리스트로부터-ndarray-객체-생성하기) 메소드 혹은 `ndarray.astype()` 메소드를 이용해 새로운 `ndarray` 객체를 만들어 주는 식으로 하여 바꿀 수 있다.

{% highlight python %}
x = np.array(x, dtype=np.float64)
# x = [[[ 0.  1.  2.]
#       [ 3.  4.  5.]]
#     
#      [[ 6.  7.  8.]
#       [ 9. 10. 11.]]]

x = x.astype(np.bool)
# x = [[[False  True  True]
#       [ True  True  True]]
#     
#      [[ True  True  True]
#       [ True  True  True]]]
{% endhighlight %}

메소드 [`ndarray.astype()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.astype.html)는 형변환(casting)된 새 `ndarray` 객체를 반환하는 메소드로서 다음과 같은 인자를 받는다.

- `dtype` : 형변환(casting)하고자 하는 데이터 타입

# ndarray 생성하기

## 파이썬 리스트로부터 ndarray 객체 생성하기

메소드 [`np.array()`](https://numpy.org/doc/stable/reference/generated/numpy.array.html)는 파이썬 리스트로부터 배열을 생성하는 메소드이다.

{% highlight python %}
x = np.array(object=[[1, 2, 3], [4, 5, 6]])
# x = [[1 2 3]
#      [4 5 6]]
{% endhighlight %}

`np.array()`는 다음과 같은 인자를 받는다.

- `object` : [필수] 파이썬 리스트[^4]
- `dtype` : 데이터 타입. 명시하지 않았다면 `object`의 데이터 타입을 사용한다.[^5]

[^4]: 정확히는, 파이썬 리스트, 튜플, `range()`, `ndarray` 객체 등과 같은 배열스러운(array_like) 객체들.
[^5]: 위 예시의 경우, `np.int64`.

## 0으로 초기화된 ndarray 객체 생성하기

메소드 [`np.zeros()`](https://numpy.org/doc/stable/reference/generated/numpy.zeros.html)는 0으로 초기화된 배열을 생성하는 메소드이다.

{% highlight python %}
x = np.zeros(shape=(2, 3))
# x = [[0. 0. 0.]
#      [0. 0. 0.]]
{% endhighlight %}

`np.zeros()`는 다음과 같은 인자를 받는다.

- `shape` : [필수] 배열의 크기. 정수(ex. `2`) 혹은 정수 튜플(ex. `(2, 3)` 혹은 `[2, 3]`)
- `dtype` : 데이터 타입. 명시하지 않았다면 `np.float64`를 사용한다.

## 1로 초기화된 ndarray 객체 생성하기

메소드 [`np.ones()`](https://numpy.org/doc/stable/reference/generated/numpy.ones.html)는 1로 초기화된 배열을 생성하는 메소드이다.

{% highlight python %}
x = np.ones(shape=(2, 3))
# x = [[1. 1. 1.]
#      [1. 1. 1.]]
{% endhighlight %}

`np.ones()`는 다음과 같은 인자를 받는다.

- `shape` : [필수] 배열의 크기. 정수(ex. `2`) 혹은 정수 튜플(ex. `(2, 3)` 혹은 `[2, 3]`)
- `dtype` : 데이터 타입. 명시하지 않았다면 `np.float64`를 사용한다.

## 특정 값으로 초기화된 ndarray 객체 생성하기

메소드 [`np.full()`](https://numpy.org/doc/stable/reference/generated/numpy.full.html)는 특정 값으로 초기화된 배열을 생성하는 메소드이다.

{% highlight python %}
x = np.full(shape=(2, 3), fill_value=3)
# x = [[3 3 3]
#      [3 3 3]]

x = np.full(shape=(2, 3), fill_value=[3, 1.5, 4])
# x = [[3. 1.5 4.]
#      [3. 1.5 4.]]

x = np.full(shape=(2, 3), fill_value=[3, 1])  # error!
{% endhighlight %}

`np.full()`는 다음과 같은 인자를 받는다.

- `shape` : [필수] 배열의 크기. 정수(ex. `2`) 혹은 정수 튜플(ex. `(2, 3)` 혹은 `[2, 3]`)
- `fill_value` : [필수] 배열을 채울 값. 스칼라 값 혹은 배열스러운(array_like) 값
- `dtype` : 데이터 타입. 명시하지 않았다면 `fill_value`의 데이터 타입을 사용한다.

`fill_value`에는 배열스러운(array_like) 값을 넣을 수도 있는데, 마지막 예시에서처럼 `shape`의 크기로 broadcasting이 되지 않는 크기의 값을 넣을 경우 오류가 발생한다.

대부분의 경우 배열을 0 또는 1로 초기화하기 때문에 그렇게 많이 쓰이진 않지만, 알아두면 유용하다.

## 초기화되지 않은 ndarray 객체 생성하기

메소드 [`np.empty()`](https://numpy.org/doc/stable/reference/generated/numpy.empty.html)는 초기화하지 않는 새 배열을 생성하는 메소드이다.

{% highlight python %}
x = np.empty(shape=(2, 3))
# x = [[4.63640824e-310 0.00000000e+000 0.00000000e+000]
#      [0.00000000e+000 0.00000000e+000 0.00000000e+000]]  # Random Value
{% endhighlight %}

`np.empty()`는 다음과 같은 인자를 받는다.

- `shape` : [필수] 배열의 크기. 정수(ex. `2`) 혹은 정수 튜플(ex. `(2, 3)` 혹은 `[2, 3]`)
- `dtype` : 데이터 타입. 명시하지 않았다면 `np.float64`를 사용한다.

`np.empty()`로 만들어진 배열에는 쓰레기 값(garbage)이 채워져 있다. 대신 초기화를 하지 않기 때문에 `np.zeros()`나 `np.ones()`에 비해 속도가 조금 빠르다는 장점이 있다.

주의할 것은, `np.empty()`는 랜덤한 값으로 초기화된 배열을 만드는 것이 아니라는 것이다. 랜덤한 값으로 초기화하고 싶으면 `np.random.randn()` 등의 메소드를 사용해야 한다.

## 이미 존재하는 배열과 유사한 ndarray 객체 생성하기

메소드 [`np.zeros_like()`](https://numpy.org/doc/stable/reference/generated/numpy.zeros_like.html), [`np.ones_like()`](https://numpy.org/doc/stable/reference/generated/numpy.ones_like.html), [`np.empty_like()`](https://numpy.org/doc/stable/reference/generated/numpy.empty_like.html), [`np.full_like()`](https://numpy.org/doc/stable/reference/generated/numpy.full_like.html)를 이용하면 기존에 존재하는 배열과 같은 속성(`shape`, `dtype`)을 갖는 새 배열을 생성할 수 있다.

{% highlight python %}
x = np.array([[1, 2, 3], [4, 5, 6]])
# x = [[1 2 3]
#      [4 5 6]]

a = np.zeros_like(x)
# a = [[0 0 0]
#      [0 0 0]]

b = np.ones_like(x)
# b = [[1 1 1]
#      [1 1 1]]

c = np.full_like(x, fill_value=0.1)
# c = [[0 0 0]
#      [0 0 0]]

d = np.empty_like(x)
# d = [[-1073741821   2 8663128]
#      [        654 -56    3541]]  # Random Value
{% endhighlight %}

`np.zeros_like()`, `np.ones_like()`, `np.empty_like()`는 다음과 같은 인자를 받는다.

- `a`[^6] : [필수] 속성을 복사할 배열
- `dtype` : 데이터 타입. 명시할 경우 `a`의 데이터 타입을 덮어쓴다(override).

[^6]: `np.empty_like()`의 경우 `prototype`을 인자의 이름으로 쓴다.

`np.full_like()`는 다음과 같은 인자를 받는다.

- `a` : [필수] 속성을 복사할 배열
- `fill_value` : [필수] 배열을 채울 값
- `dtype` : 데이터 타입. 명시할 경우 `a`의 데이터 타입을 덮어쓴다(override).

`dtype` 속성을 명시할 경우 원본 배열의 데이터 타입(dtype)을 무시하고 명시된 속성을 사용한다. `dtype`이 명시되지 않았다면 원본 배열의 데티어 타입이 사용된다. 위 `np.full_like()` 메소드의 예시에서, 원본 배열 `x`의 데이터 타입이 `np.int64`이므로 `fill_value`로 0.1을 주었지만 `c`는 0으로 초기화된 것이다. 만약 0.1로 초기화하고 싶다면 다음과 같이 dtype을 `np.float64`로 명시해 주면 된다.

{% highlight python %}
c = np.full_like(x, fill_value=0.1, dtype=np.float64)
# c = [[0.1 0.1 0.1]
#      [0.1 0.1 0.1]]
{% endhighlight %}

주의할 것은 `_like()` 류 메소드들을 사용해도 원본 배열로부터 값은 복사되지 않는다는 것이다. 만약 기존 `ndarray` 객체로부터 값까지 복사한 복제본을 만들고 싶다면 [`np.array()`](#kramdown_파이썬-리스트로부터-ndarray-객체-생성하기) 또는 `np.copy()` 메소드를 사용해야 한다.

## 기타

### np.eye()

메소드 [`np.eye()`](https://numpy.org/doc/stable/reference/generated/numpy.eye.html)를 이용하면 왼쪽 위에서 오른쪽 아래 방향으로 가는 대각선 성분만 1로 채우고 나머지 성분은 0으로 채운 배열을 쉽게 얻을 수 있다.

{% highlight python %}
x = np.eye(N=3)
# x = [[1. 0. 0.]
#      [0. 1. 0.]
#      [0. 0. 1.]]

x = np.eye(N=2, M=3)
# x = [[1. 0. 0.]
#      [0. 1. 0.]]

x = np.eye(N=2, M=3, k=1)
# x = [[0. 1. 0.]
#      [0. 0. 1.]]

x = np.eye(N=2, M=3, k=-1)
# x = [[0. 0. 0.]
#      [1. 0. 0.]]

x = np.eye(N=2, M=3, k=-2)
# x = [[0. 0. 0.]
#      [0. 0. 0.]]
{% endhighlight %}

`np.eye()`는 다음과 같은 인자를 받는다.

- `N` : [필수] 행(row)의 개수
- `M` : 열(column)의 개수. 명시하지 않으면 `N`과 동일한 값. (즉, 정사각행렬)
- `k` : 오프셋. 양수는 오른쪽 위, 음수는 왼쪽 아래 대각선을 의미한다. 명시하지 않으면 0.
- `dtype` : 데이터 타입. 명시하지 않으면 `np.float64`를 사용한다.

`k`를 이용하면 1로 초기화되는 대각선 성분의 오프셋을 지정할 수 있다. `k`값이 0이면(기본값) (0, 0) 성분에서부터 시작하는 대각선 성분이 1로 초기화되고, 나머지는 0으로 초기화된다. `k`값이 양수면 오른쪽 위로 한 칸씩 올라간다. 예를 들어, `k=1`이면, (0, 1) 성분으로부터 시작하는 대각선 성분이 1로 초기화된다. `k`값이 음수면 왼쪽 아래로 한 칸씩 내려간다. 예를 들어, `k=-1`이면, (1, 0) 성분으로부터 시작하는 대각선 성분이 1로 초기화된다.

만약 정말로 순수한 정사각 단위행렬(Identity Matrix)을 만들고 싶다면 [`np.identity()`](https://numpy.org/doc/stable/reference/generated/numpy.identity.html) 메소드를 사용할 수 있다.

{% highlight python %}
x = np.identity(3)
# x = [[1. 0. 0.]
#      [0. 1. 0.]
#      [0. 0. 1.]]
{% endhighlight %}

`np.identity()`는 다음과 같은 인자를 받는다.

- `n` : [필수] (정사각행렬의) 행(열)의 개수
- `dtype` : 데이터 타입. 명시하지 않으면 `np.float64`를 사용한다.

`np.identity()`는 직사각행렬을 만들 수 없지만 `np.eye()`는 가능하다는 차이가 있다.

### np.arange()

[`np.arange()`](https://numpy.org/doc/stable/reference/generated/numpy.arange.html) 메소드는 파이썬 기본 문법에서 제공하는 `range()` 함수와 유사한 메소드이다. 이 메소드를 이용하면 연속된 값으로 초기화된 1차원 배열을 얻을 수 있다.

{% highlight python %}
x = np.arange(10)
# x = [0 1 2 3 4 5 6 7 8 9]

x = np.arange(start=3, stop=10, step=2)
# x = [3 5 7 9]
{% endhighlight %}

`np.arange()`는 다음과 같은 인자를 받는다.

- `start` : 시작값. 명시하지 않으면 0.
- `stop`[^7] : [필수] 종료값. `np.arange()`는 반개구간(half-open interval) 표기법[^8]을 사용하기에, 종료값은 출력되지 않는다.
- `step` : 출력될 값들 사이 간격. 명시하지 않으면 1.
- `dtype` : 데이터 타입. 명시하지 않으면 `start`, `stop`, `step` 값에서 알아서 추론하여 사용한다.

[^7]: 이 메소드의 유일한 필수 인자값이 `stop` 인자이다. 하지만 인자 순서가 두 번째이기 때문에, `np.arange(stop=10)`과 같이 단일 인자만 사용할 때 인자 이름 `stop`을 명시하면 오류가 발생한다. 이는 파이썬 구현 상 실제 필수 인자가 첫 번째 인자인 `start`로 되어 있어서 그렇다(단일 인자만 전달될 때는 메소드 내부적으로 전달받은 `start` 값을 `stop`에 넘기고, `start`를 0으로, `step`을 1로 초기화하여 사용한다). 따라서 `stop` 인자만을 사용하고 싶을 때는 인자 이름을 명시하지 않고 (위 예시처럼) `np.arange(10)`의 형태로 사용하던가, 논리적으로 맞진 않지만 `np.arange(start=10)`의 형태로 사용해야 한다.
[^8]: [`start`, `stop`)

`np.arange()`는 [`ndarray.reshape()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.reshape.html) 메소드와 함께 자주 사용된다. `ndarray.reshape()`는 전달받은 `shape` 인자의 크기대로 만든 새로운 배열에 원본 배열의 요소(element)들을 앞에서부터 채워넣어 반환한다.[^9] `ndarray.reshape()`를 이용하면 `np.arange()`로 만들어진 1차원 배열을 다차원 배열로 바꿀 수 있다.

[^9]: C언어에서의 다차원 배열은 사실 연속적인 1차원 배열이므로 전체 요소들에 연속적인 접근이 가능하다는 개념과 유사하다. 

{% highlight python %}
x = np.arange(10).reshape(2, 5)
# x = [[0 1 2 3 4
#       5 6 7 8 9]]

x = np.arange(10).reshape((2, 5))
# x = [[0 1 2 3 4
#       5 6 7 8 9]]

x = np.arange(12).reshape(2, 2, 3)
# x = [[[ 0  1  2]
#       [ 3  4  5]]
#     
#      [[ 6  7  8]
#       [ 9 10 11]]]

x = np.arange(10).reshape(2, -1)
# x = [[0 1 2 3 4
#       5 6 7 8 9]]

x = np.arange(10).reshape(-1, 5)
# x = [[0 1 2 3 4
#       5 6 7 8 9]]

x = np.arange(10).reshape(-1)
# x = [0 1 2 3 4 5 6 7 8 9]

x = np.arange(10).reshape(2, 3)  # error!
x = np.arange(10).reshape(2)  # error!
x = np.arange(12).reshape(2, -1, -1)  # error!
{% endhighlight %}

`ndarray.reshape()`는 다음과 같은 인자를 받는다.

- `shape`[^10] : 배열의 크기(shape)

[^10]: 인자명을 명시하며 `shape=(3, 2, 1)` 형태로 값을 전달하면 오류가 발생한다. 왜 이런 현상이 일어나는지는 잘 모르겠다.

`shape`는 묶어서 전달할 수도 있고(`x = np.arange(10).reshape((2, 5))`) 풀어서 전달할 수도 있다(`x = np.arange(10).reshape(2, 5)`).

또한 `shape`의 요소로 -1을 사용할 수도 있다. 이 경우 `ndarray.reshape()`는 원본 배열의 원소의 개수와 전달받은 나머지 shape의 요소를 이용해 -1 값을 추정한다. 예를 들어, `x = np.arange(10).reshape(2, -1)`에서, `ndarray.reshape()`는 -1이 5[^10]임을 추정하여 2×5 배열을 만들어 준다. 당연히 -1은 두 개 이상 사용할 수 없다.[^11]

[^11]: 전체 데이터 수가 10개이므로, 10 ÷ 2 = 5
[^12]: 두 개 이상이면 추정할 수 없지 않은가.

앞에서 설명했다시피 `ndarray`는 크기가 한번 정해지면 바꿀 수 없다. `ndarray.reshape()` 역시 크기를 '바꾸는' 것이 아니라, `shape` 크기를 가지는 새로운 배열을 '만드는' 것이다. 다시말해, `ndarray.reshape()`는 원본 배열을 바꾸지 않는다는 점을 유의하기 바란다.

### np.ndarray()

[`np.ndarray()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html) 메소드를 직접 이용해도 `ndarray` 객체를 만들 수 있다.

{% highlight python %}
x = np.ndarray(shape=(2, 3), dtype=np.float64)
# x = [[0.0e+000 4.9e-324 9.9e-324]
#      [1.5e-323 2.0e-323 2.5e-323]]  # Random Value
{% endhighlight %}

`np.ndarray()`는 다음과 같은 인자를 받는다.

- `shape` : [필수] 배열의 크기(shape)
- `dtype` : 데이터 타입. 명시하지 않으면 `np.float64`를 사용한다.

`np.ndarray()`로 만들어진 배열은 초기화되지 않은 배열이다.

앞에서 나왔던 `np.empty()`, `np.ones()`, `np.zeros()`와 같은 메소드들은 모두 내부적으로 `np.ndarray()`를 호출해 반환한다. `np.empty()`, `np.ones()`, `np.zeros()`와 같은 메소드들은 `np.ndarray()`를 더 잘 쓸 수 있게 포장해 놓은 메소드들이므로, `np.ndarray()`를 직접 호출하여 사용하는 것보다 앞에서 나왔던 `np.empty()`와 같은 메소드를 사용하는 것이 더 권장된다.

# ndarray 요소 값 읽기/수정하기

다음과 같이 2×2×3 배열 `x`가 주어졌다고 해 보자.

{% highlight python %}
x = np.arange(12).reshape(2, 2, 3)
# x = [[[ 0  1  2]
#       [ 3  4  5]]
#     
#      [[ 6  7  8]
#       [ 9 10 11]]]
{% endhighlight %}

파이썬의 리스트에서와 마찬가지로 대괄호([])를 이용하면 배열의 원소에 접근할 수 있다. 대괄호 안에 각 차원에서의 인덱스를 적으면 된다. 예를 들어, 원소 5은 다음과 같이 접근할 수 있다.

{% highlight python %}
# 읽기
print(x[0][1][2])  # 5

# 쓰기
x[0][1][2] = 99
# x = [[[ 0   1   2]
#       [ 3   4  99]]
#     
#      [[ 6   7   8]
#       [ 9  10  11]]]
{% endhighlight %}

또는 다음과 같이 한 대괄호 안에서 각 차원의 인덱스를 쉼표로 구분하여 쓰는 형태로 접근할 수도 있다.

{% highlight python %}
# 읽기
print(x[0, 1, 2])  # 5

# 쓰기
x[0, 1, 2] = 99
# x = [[[ 0   1   2]
#       [ 3   4  99]]
#     
#      [[ 6   7   8]
#       [ 9  10  11]]]
{% endhighlight %}

일반적으로는 두 번째 방법이 앞의 대괄호를 여러 번 쓰는 첫 번째 방법에 비해 더 편하기에 더 자주 사용된다.

참고로 두 번째 방법은 파이썬의 배열에서는 사용할 수 없다.~~NumPy에 익숙해지면 파이썬 리스트에서 이 방법을 쓰고 오류를 찾지 못해 당황하게 된다~~