---
title: "지킬(Jekyll) 기초"
order: 2
date: "2020-12-09"
---

# 지킬 설치하기

지킬을 사용하기 가장 편한 환경은 리눅스 환경이다.[^1] Windows, macOS 사용자들은 Oracle VM VirtualBox와 같은 가상화 프로그램에 리눅스를 설치해 사용하는 것을 추천한다.[^2] 본 문서에서는 리눅스(우분투) 환경에 지킬을 설치하는 방법을 설명하도록 하겠다.[^3]

[^1]: macOS의 경우 사용 가능하긴 한데 사용자 수가 적어 문제가 발생했을 때 고치는 것이 어렵기에 추천하지 않는다. Windows의 경우 지킬이 공식적으로 지원하지 않는다.
[^2]: Windows의 경우 WSL2를 사용하는 것도 하나의 방법이 될 수 있다. 하지만 권한 문제 등 소소한 이슈가 있기에(현재 개발중이라고 한다) 가상화 프로그램을 사용하는 것을 더 추천한다.
[^3]: 다른 리눅스 배포판을 사용하는 경우 [공식 문서](https://jekyllrb.com/docs/installation/other-linux/)를 참고하도록 하자.

우선 루비를 설치해야 한다.

{% highlight bash %}
$ sudo apt update
$ sudo apt -y install ruby-full build-essential zlib1g-dev
{% endhighlight %}

루비 라이브러리를 루비 잼(Ruby Gem)이라 부른다. 지킬 및 지킬에서 사용하는 플러그인들은 루비 잼 형태로 만들어져 있다. 따라서 지킬을 사용하려면 다음과 같이 루비 잼이 설치될 디렉토리를 설정해야 한다. `~/.bashrc` 파일에 환경 변수를 설정한 다음 다시 로딩하자.

{% highlight bash %}
$ echo '# Install Ruby Gems to ~/gems' >> ~/.bashrc
$ echo 'export GEM_HOME="$HOME/gems"' >> ~/.bashrc
$ echo 'export PATH="$HOME/gems/bin:$PATH"' >> ~/.bashrc
$ source ~/.bashrc
{% endhighlight %}

이제 지킬 Gem을 설치한다.

{% highlight bash %}
$ gem install jekyll bundler
{% endhighlight %}

# 지킬 시작하기

`jekyll new` 명령어를 이용하면 지킬 디렉토리를 만들 수 있다.

{% highlight bash %}
$ jekyll new ./    # 현재 디렉토리를 지킬 디렉토리로 만들기
$ jekyll new asdf  # 현재 디렉토리 밑에 asdf 디렉토리를 만들고, 이를 지킬 디렉토리로 만들기
{% endhighlight %}

`jekyll new` 명령어로 만들어지는 지킬 디렉토리의 구조는 다음과 같다.

{% highlight text %}
./
├── 404.html
├── Gemfile
├── Gemfile.lock
├── _config.yml
├── _posts
│   └── 2020-12-09-welcome-to-jekyll.markdown
├── about.markdown
└── index.markdown
{% endhighlight %}

각각의 파일이 무슨 역할을 하는지는 아래에서 설명하겠다.

지킬 디렉토리에서 다음 명령어를 입력하면 테스트용 라이브 서버가 열린다.[^4][^5]

[^4]: serve**r**의 오타가 아니다. 그런데 server라 입력해도 서버가 열린다.~~??!!~~
[^5]: 공식 문서에서는 `jekyll serve` 명령어를 소개하고 있다. 하지만 지킬에 플러그인이 설치되어 있다면 `jekyll serve` 명령어로 라이브 서버를 열 때 `Gem::LoadError`와 같은 오류가 뜰 수 있다. 하지만 `bundle exec jekyll serve` 명령어는 플러그인이 설치되어 있던 있지 않던 항상 성공하는 명령어이므로 이를 소개한다.

{% highlight bash %}
$ bundle exec jekyll serve
{% endhighlight %}

라이브 서버는 디폴트로 `http://127.0.0.1:4000`에서 열린다. 만약 라이브 서버가 열리는 호스트 주소와 포트 번호를 변경하고 싶다면, 다음과 같이 `--host`, `--port` 옵션을 주거나, `_config.yml` 파일을 수정하면 된다. `_config.yml` 파일 수정법은 아래에서 설명하겠다.

{% highlight bash %}
$ bundle exec jekyll serve --host <host> --port <port>
{% endhighlight %}

- <host>: 라이브 서버를 열 호스트 주소. 아무 값을 주지 않으면 디폴트로 `127.0.0.1` 값이 사용된다.
- <port>: 라이브 서버를 열 포트 번호. 아무 값을 주지 않으면 디폴트로 `4000` 값이 사용된다.

# _config.yml

`_config.yml` 파일은 지킬에서 가장 중요한, 지킬의 설정값들을 yaml 포멧으로[^6] 모아 놓은 파일이다. 지킬은 이 파일을 기반으로 웹 사이트를 빌드한다. 

[^6]: 만약 yaml 포멧을 잘 모른다면 공부하는 것을 추천한다...만, 솔직히 yaml은 5분이면 마스터할 정도로 단순한 포멧이다. 굳이 공부 안해도 `jekyll new` 명령어로 자동으로 생성된 `_config.yml` 파일을 읽어보는 것만으로도 어떻게 쓰는 건지 감이 잡힐 것이다.

참고로 `_config.yml` 파일에서는 탭을 사용하면 안 된다. 탭을 사용할 경우 지킬이 파일 해석을 실패해 오류가 발생하거나 기본값으로 폴백(fallback)해 버릴 수 있다.

`_config.yml`에서 설정 가능한 다양한 값들 중 필자가 현재 사용 중인, 많이 사용할 것 같은 설정값들을 소개해 보겠다.


## title, subtitle

`_config.yml`의 설정값들은 지킬 어디서든 `site.XXX` 형태로 접근 가능하다[^7]. 예를 들어 title, subtitle 설정값은 각각 `site.title`, `site.subtitle` 형태로 지킬 어디서든 접근 가능하다.

이 두 설정값은 반드시 있어야만 하는 설정값은 아니지만, 많은 템플릿에서 각각 블로그 이름, 부제를 설정하는 항목으로 사용된다.

[^7]: 자세한 것은 liquid 문법을 다룰 때 다시 설명하겠다.

## url

이 설정값은 반드시 있어야만 하는 설정값은 아니지만, 많은 템플릿에서 사용하고 있다. 사이트의 url을 설정하는 값이다. 예를 들어, 본 문서의 주소인 `https://heekangpark.github.io/jekyll/02-jekyll-basics`에서 url은 `https://heekangpark.github.io/`를 의미한다. 일반적으로 아래 baseurl 설정값과 함께 쌍으로 사용된다.

## baseurl

이 설정값은 반드시 있어야 하는 설정값은 아니지만, 많은 템플릿에서 사용하고 있다. 사이트의 루트 주소를 설정하는 값이다.

만약 본 블로그에서 이 값이 "asdf"로 설정되어 있으면 본 문서의 주소는 `https://heekangpark.github.io/asdf/jekyll/02-jekyll-basics`가 되는 등, 블로그의 모든 문서가 `https://heekangpark.github.io/asdf` 밑에 생성된다. 아무 값도 입력하지 않으면 디폴트로 `""`(즉, baseurl이 없음) 값이 사용된다.

baseurl에 사이트의 url(ex. `https://heekangpark.github.io/`, `http://127.0.0.1/` 등)이 포함되지 않는 것에 주의하자.

깃허브에서 프로젝트를 만든 후 그 안에 지킬 저장소(Repository)를 만들 경우, URL이 `https://<project_name>.github.io/<repository_name>/` 형태로 배정된다. 이 경우 baseurl을 `<repository_name>`으로 설정해 주어야 한다.

## timezone

지킬 내부에서 시간을 출력할 때 사용되는 시간대를 설정할 수 있는 설정값이다. 아무 값도 입력하지 않으면 디폴트로 `null`(OS의 시간대를 사용)이 사용된다.

참고로 지킬에서는 문서의 작성 시간을 미래로 설정해 놓을 수가 있는데, 이렇게 하면 해당 시간 전까지는 문서가 공개되지 않다가 해당 시간이 지나면 문서가 공개되게 할 수 있다. 이때 timezone 설정이 잘못되어 있으면 현재 시간을 입력해도 지킬이 미래라 판단, 문서를 공개하지 않을 수 있다.

필자는 한국에 있으므로 이를 "Asia/Seoul"로 입력하였다. 다른 시간대를 사용하고 싶다면 [IANA Timezone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)에서 본인의 시간대를 찾은 후 `TZ database name`을 입력하면 된다.

## plugins

지킬에서 사용할 플러그인들을 설정할 수 있는 설정값이다. 지킬에서는 다양한 플러그인들을 사용할 수 있다. 그런데 깃허브 페이지에서는 보안상의 이유로 아주 소수의 몇몇 플러그인들을 제외한 모든 플러그인들의 사용이 금지되어 있다.[^8] 2020년 12월 현재 깃허브 페이지에서 사용 가능한 플러그인들과 그 버전들의 목록은 다음과 같다(\* 표시가 있는 플러그인은 깃허브 페이지에서 디폴트로 활성화되어 있는 플러그인으로, 비활성화가 불가능하다).

[^8]: 만약 깃허브 페이지에서 지원하지 않는 플러그인 중 죽어도 반드시 사용해야 하는 것이 있다면, 지킬은 로컬에서만 사용하고 깃허브 페이지에는 빌드된 HTML, CSS, JS 파일만 올리는 방법을 사용할 수 있다.

- jekyll (3.9.0)
- github-pages-health-check (1.16.1)
- github-pages (209)
- html-pipeline (2.14.0)
- jekyll-avatar (0.7.0)
- jekyll-coffeescript (1.1.1) *
- jekyll-commonmark-ghpages (0.1.6)
- jekyll-default-layout (0.1.4) *
- jekyll-feed (0.15.1)
- jekyll-gist (1.5.0) *
- jekyll-github-metadata (2.13.0) *
- jekyll-mentions (1.6.0)
- jekyll-optional-front-matter (0.3.2) *
- jekyll-paginate (1.1.0) *
- jekyll-readme-index (0.3.0) *
- jekyll-redirect-from (0.16.0)
- jekyll-relative-links (0.6.1) *
- jekyll-remote-theme (0.4.2)
- jekyll-sass-converter (1.5.2)
- jekyll-seo-tag (2.6.1)
- jekyll-sitemap (1.4.0)
- jekyll-swiss (1.0.0)
- jekyll-theme-architect (0.1.1)
- jekyll-theme-cayman (0.1.1)
- jekyll-theme-dinky (0.1.1)
- jekyll-theme-hacker (0.1.2)
- jekyll-theme-leap-day (0.1.1)
- jekyll-theme-merlot (0.1.1)
- jekyll-theme-midnight (0.1.1)
- jekyll-theme-minimal (0.1.1)
- jekyll-theme-modernist (0.1.1)
- jekyll-theme-primer (0.5.4)
- jekyll-theme-slate (0.1.1)
- jekyll-theme-tactile (0.1.1)
- jekyll-theme-time-machine (0.1.1)
- jekyll-titles-from-headings (0.5.3) *
- jemoji (0.12.0)
- kramdown-parser-gfm (1.1.0)
- kramdown (2.3.0)
- liquid (4.0.3)
- minima (2.5.1)
- nokogiri (1.10.10)
- rouge (3.23.0)
- ruby (2.7.1)
- safe_yaml (1.0.5)
- sass (3.7.4)

참고로 깃허브 페이지는 보안상의 이유로 플러그인들의 버전이 맞지 않아도 경고를 출력하거나 빌드에 실패하므로, 플러그인의 버전들도 잘 맞춰주도록 하자.

본 블로그에서는 현재 `jekyll-sitemap`, `jekyll-feed` 두 개의 플러그인을 사용중이다.

## include, exclude

지킬은 기본적으로 빌드 시 `.(dot)`으로 시작하는 파일, `.(dot)` 또는 `_(underscore)`으로 시작하는 디렉토리를 제외한 모든 파일 및 디렉토리를 빌드한다. 이때, exclude 설정을 이용하면 빌드에 포함하지 않을 파일과 디렉토리를 설정할 수 있다.

아무런 값을 설정하지 않을 경우 exclude 설정은 디폴트로 `["Gemfile", "Gemfile.lock", "node_modules", "vendor/bundle/", "vendor/cache/", "vendor/gems/", "vendor/ruby/"]`을 사용한다.

본 블로그는 `["run", "commit", "README.md", "Gemfile", "Gemfile.lock"]`을 사용하고 있다. 참고로 `run`, `commit`는 필자가 직접 만든 빌드 스크립트, 배포 스크립트이다.

include 설정을 이용하면 exclude 설정과 반대로 빌드 시 반드시 포함될 파일 및 디렉토리를 설정할 수 있다. 상술했듯이 지킬은 모든 파일 및 디렉토리를 빌드해 버리므로 거의 쓸 일이 없는 설정이다. 만약 `.`으로 시작하는 파일 중 빌드에 반드시 포함되어야 하는 파일이 있다면 사용할 만 하다.

사족으로 `.`으로 시작하는 파일이 빌드되지 않는다는 점을 이용해 블로그 포스트 초안(draft)을 만들 수 있다. 로컬에서 테스트할 때는 `.`으로 시작하지 않는 파일명을 사용해 빌드했다가, 커밋할 때(깃허브 페이지에 올릴 때) 파일명 앞에 `.`을 붙이면 빌드되지 않으므로 깃허브 페이지에 배포되지 않는다.[^9]

[^9]: 지킬에서 자체적으로 초안 작성을 위한 draft 기능을 제공하긴 하는데, 여러 모로 사용하기 불편했다. 개인적으로 이렇게 `.`을 이용한 방법을 추천한다.

## host, port

`bundle exec jekyll serve` 명령으로 실행되는 테스트 서버가 실행될 호스트 주소, 포트 번호를 설정할 수 있는 설정값이다. 아무런 값을 설정하지 않을 경우 host는 디폴트로 `http://127.0.0.1/`을, port는 디폴트로 `4000`을 사용한다.

## kramdown

kramdown이란 마크다운 엔진의 한 종류로, 지킬에서 디폴트 마크다운 엔진으로 사용된다. kramdown 설정을 이용하면 kramdown 마크다운 엔진이 사용할 설정값을 지정할 수 있다.

다음은 kramdown 설정값을 설정한 예시이다.

{% highlight yaml %}
kramdown:
  auto_id_prefix: "kramdown_"
  auto_ids: true
  smart_quotes: ["apos", "apos", "quot", "quot"]
{% endhighlight %}

kramdown 설정 중 본 블로그에서 사용중이거나 많이 사용되는 설정들을 알아보자.

### auto_ids, auto_id_prefix

auto_ids는 마크다운 헤더(Header)를 HTML 헤더로 변환할 때 자동으로 id를 생성할 지 말지를 설정하는 설정값이다. `ture`/`false` 값을 사용할 수 있고, 아무 값도 설정하지 않았을 때의 기본값은 `true`이다(즉, 변환 시 자동으로 id를 생성한다).

자동으로 생성된 id는 헤더의 내용에서 변환 불가능한 문자들(ex. 괄호(`(`, `)`), 쉼표(`,`) 등)을 모두 제거한 후 공백을 모두 `-`으로 바꾼 것이다. 예를 들어, 헤더 `### auto_ids, auto_id_prefix`의 id는 `auto_ids-auto_id_prefix`가 된다.

auto_id_prefix는 자동으로 생성되는 id의 prefix(접두사)를 설정하는 설정값이다. 아무 값도 사용하지 않으면 `""`값이 디폴트로 사용된다(즉, prefix가 없다).

### footnote_nr, footnote_backlink

footnote_nr은 각주 시작 번호를 설정하는 설정값이다. 아무 값도 사용하지 않으면 디폴트로 `1`이 사용된다.

footnote_backlink는 각주에서 본문으로 돌아가는 하이퍼링크 아이콘의 모양을 설정하는 설정값이다. 아무 값도 사용하지 않으면 디폴트로 `U+21A9`(↩)가 사용된다.

### header_offset

header_offset 설정을 이용하면 마크다운 헤더가 HTML 헤더로 변환할 때의 오프셋을 설정할 수 있다.

예를 들어, 오프셋이 3이면 다음과 같이 변환된다.

- `# asdf` → <h4>
- `## asdf` → <h5>
- `### asdf` → <h6>
- `#### asdf` → <h6>
- `##### asdf` → <h6>
- `###### asdf` → <h6>

아무 값도 설정하지 않았을 때의 기본값은 `0`(즉, 오프셋이 없다)이다.

### math_engine

지킬에서 수식 등을 표현하는 데 사용하는 수학 엔진(Math Engine)을 설정하는 설정값이다. 아무 값도 입력하지 않을 경우의 기본값은 `mathjax`이다. MathJax는 수식을 표현할 수 있는 라이브러리로, 자바스크립트로 작성되었다. 본 블로그에서도 MathJax를 사용해 수식을 표현한다.
 
주의할 것은 이 설정값에 `mathjax`라 값을 줘도 바로 MathJax를 사용할 수 있는 것은 아니라는 것이다. 이 설정값에 `mathjax`라 값을 주면 MathJax에서 변환이 가능하도록 포멧을 맞춰주는 것이 전부이다. 실제 변환은 MathJax 라이브러리가 담당한다. 따라서 실제로 MathJax를 사용하기 위해서는 MathJax 자바스크립트 라이브러리를 문서에 포함시켜 줘야 한다. 자세한 사용법은 해당 문서를 참조하자.

### syntax_highlighter

마크다운에서는 백쿼트(Back Quote, `\``)[^10] 한 쌍을 이용해 인라인 코드(inline code)를, 백쿼트 세 쌍을 이용해 블록 코드(block code)를 표현할 수 있다(자세한 내용은 마크다운 문법 문서를 참조하기 바란다). syntax_highlighter는 이때 사용할 코드 구문강조 모듈을 설정하는 설정값이다. 아무 값도 사용하지 않으면 기본값으로 rouge 구문강조 모듈이 사용된다.

[^10]: 백틱(Back Tick)이라고도 부른다.

참고로 지킬에서는 코드를 작성하는 방법이 3가지 정도 있다.

- 마크다운(kramdown) 문법 이용하기 : 상술했듯이 한 쌍(인라인 코드) 혹은 세 쌍(블록 코드)의 백쿼트 사이에 코드를 작성할 수 있다. 마크다운 엔진이 문서를 변환할 때 HTML 코드 요소(`<code>`, `<pre>` 등)로 변환된다.
- Liquid 문법 이용하기 : `{% raw %}{% highlight %}{% endhighlight %}{% endraw %}` 구문을 이용하면 블록 코드를 작성할 수 있다. Liquid 엔진이 문서를 변환할 때 HTML 코드 요소(`<code>`, `<pre>` 등)로 변환된다.
- js 라이브러리 이용하기 : `highlight.js`와 같은 외부 라이브러리를 사용하는 방법으로, 정해진 키워드 사이에 코드를 작성할 수 있다(키워드는 라이브러리마다 조금씩 다르다). 문서가 브라우저에서 로딩된 이후 동적으로 스타일이 적용된다.

참고로 본 블로그에서는 인라인 코드를 표현하기 위해 마크다운 문법을(백쿼트), 블록 코드를 표현하기 위해 Liquid 문법을 이용하고 있다.

### smart_quotes

Kramdown은 마크다운 문서를 변환할 때 작은따옴표(`'`, `U+0027`)와 큰따옴표(`"`, `U+0022`)를 왼쪽 작은따옴표(`‘`, `U+2018`), 오른쪽 작은따옴표(`’`, `U+2019`), 왼쪽 큰따옴표(`“`, `U+201C`), 오른쪽 큰따옴표(`”`, `U+201D`)로 변경할 수 있다. 이를 위해 사용하는 설정이 바로 smart_quotes이다.

하지만 개인적으로 필자는 왼쪽/오른쪽 구분된 작은따옴표와 큰따옴표보다 그냥 작은따옴표와 큰따옴표를 더 선호하고, 또 이 변환이 완벽하지 않기에(가끔 오른쪽 따옴표가 나와야 할 자리에 왼쪽 따옴표가 나온다), 자동변환 되지 않도록 설정하여 사용하고 있다.

smart_quotes는 4개의 요소를 가진 배열을 그 값으로 받을 수 있는데, 각각 왼쪽 작은따옴표가 나올 자리, 오른쪽 작은따옴표가 나올 자리, 왼쪽 큰따옴표가 나올 자리, 오른쪽 큰따옴표가 나올 자리에 어떤 기호를 쓸 지를 의미하는 값이다. smart_quotes에 아무런 값이 설정되지 않았을 때 기본값으로 `["rsquo", "rsquo", "ldquo", "rdquo"]`가 사용된다(즉, 자동변환하여 사용). 본 블로그에서는 자동변환 되지 않도록 smart_quotes에 `["apos", "apos", "quot", "quot"]`를 사용하고 있다.

### toc_levels

Kramdown에서는 `{: toc}`라 입력하면 자동으로 문서의 헤더를 수집해 목차(Table of Contents)를 만들어 주는 기능이 있다. 이때 toc_levels를 이용하면 몇 단계 헤더를 목차에 올릴지를 설정할 수 있다.

예를 들어 `1..4`이라 되어 있으면 1, 2, 3, 4단계 헤더(`# asdf`,`## asdf`, `### asdf`, `#### asdf`)만을 목차에 올리고, 5, 6단계 헤더(`##### asdf`, `###### asdf`)는 목차에 올리지 않는 것이다. 아무 값도 설정하지 않았을 때 디폴트로 사용되는 설정은 `1..6`이다(즉, 전체 헤더를 모두 목차에 올린다).

하지만 본 블로그는 Kramdown에서 제공하는 목차가 아닌, Liquid 문법을 이용해서 만들어지는 목차를 사용하고 있다. Kramdown으로 생성되는 목차는 커스터마이징이 매우 힘들기 때문이다.

# 지킬 디렉토리 구조



# 지킬 랜더링 순서

지킬에서 파일의 빌드는 다음 순서로 이루어진다.

1. 사이트 변수 해석 : 가장 먼저 `site.title`, `site.pages`, `site.collections`와 같은 사이트 변수들이 해석된다. 페이지의 태그, 카테고리, permalink 등이 이 단계에서 해석된다.
2. Liquid 해석 : Front Matter가 있는 문서들에 대해, Liquid 태그 및 변수들이 해석된다.[^11]
3. 마크다운(Kramdown) 변환 : 마크다운 변환기가 마크다운 파일[^12]들을 HTML 문서로 변환한다.
4. 레이아웃 파일과 병합 : 각 문서의 Front Matter에 명시된 레이아웃 파일[^13]과 각 문서의 내용을 합쳐 하나의 문서를 만든다.
5. 파일 생성 : 만들어진 문서들을 permalink 설정 등에 맞는 적절한 디렉토리 구조를 갖도록 `_site/` 밑에 파일을 생성한다.

[^11]: Front Matter가 없는 문서에서는 Liquid 태그 및 변수들이 해석되지 않는다. 즉, Liquid를 사용하기 위해서는 Front Matter를 반드시 넣어야 한다.
[^12]: 마크다운 확장자를 가지고 있는 파일이어야 한다. 참고로 지킬이 인식할 마크다운 확장자는 `_config.yml`에서 markdown_ext 설정으로 설정 가능하다. 아무 값도 주지 않을 경우 기본적으로 `.markdown`, `.mkdown`, `.mkdn`, `.mkd`, `.md` 확장자만을 인식한다.
[^13]: 모든 문서는 사용할 레이아웃을 `layout: xxx` 형태로 Front Matter에 명시해야 한다(혹은 `_config.yml`에서 defaults 설정으로 명시할 수도 있다). 원칙적으로 반드시 레이아웃을 명시해야 하지만, 실험 결과 레이아웃을 명시하지 않아도 "default"라는 이름을 가진 레이아웃이 있다면 이를 사용하는 것으로 보인다. 혹시나 모를 오동작을 방지하기 위해 레이아웃을 반드시 명시하도록 하자.

이 순서는 사실 대부분의 경우 몰라도 아무 지장이 없지만, 가끔 파일이 원하는 대로 랜더링되지 않을 때 참고할 만하다. 공식 문서에서는 랜더링 순서 때문에 문제가 발생하는 시나리오를 몇 가지 제시하고 있는데, 같이 살펴보자.

## 오류 시나리오 1 : 페이지에서 사용하는 Liquid 변수가 레이아웃 파일에 정의되어 있는 경우

레이아웃 파일 `_layout/default.html` 어딘가에 다음과 같이 Liquid 변수를 선언했다고 해 보자.

{: .code-header}
_layout/default.html

{% highlight liquid %}
⋮
{%- raw -%}
{% assign myvar = "joe" %}
{% endraw %}
⋮
{% endhighlight %}

이제 이 레이아웃 파일을 사용하는 문서 `page.md`에서 `myvar`를 참조하는 경우를 생각해 보자.[^14]

[^14]: 사실 레이아웃 파일에서 선언된 변수를 문서 본문에서 사용하는 것은 디자인적인 관점에서 별로 좋은 설계가 아니다. 레이아웃과 컨텐츠는 철저히 분리할수록 좋은 디자인이기 때문이다.

{: .code-header}
page.md

{% highlight liquid %}
---
layout: default
---
⋮
{%- raw -%}
{{ myvar }}
{% endraw %}
⋮
{% endhighlight %}

레이아웃이 합쳐지는 단계는 4단계로, Liquid 태그 및 변수가 해석되는 2단계보다 나중이다. 따라서 이 경우 2단계에서 `page.md`의 `myvar` 변수를 해석할 수 없어 파일의 빌드가 실패한다.

## 오류 시나리오 2 : 마크다운 문서를 HTML 파일에 include하는 경우

Liquid의 include 구문(`{% raw %}{% include %}{% endraw %}`)을 사용하면 문서 안에 다른 문서를 넣을 수(포함시킬 수) 있다. 이때, 다음과 같이 마크다운으로 작성된 `_includes/markdown.md` 문서를 `page.html` 문서에 include하는 경우를 생각해 보자.

{: .code-header}
_includes/markdown.md

{% highlight markdown %}
This is a list:
* list item 1
* list item 2
{% endhighlight %}

{: .code-header}
page.html

{% highlight html %}
⋮
{%- raw -%}
{% include markdown.md %}
{% endraw %}
⋮
{% endhighlight %}

include 구문은 Liquid가 해석되는 2단계에서 처리된다. 2단계를 지나면 `_includes/markdown.md` 파일 안의 내용은 그대로 `page.html` 파일 안에 들어간다. 이제 마크다운이 변환되는 3단계에 진입한다. 그런데 마크다운 엔진은 마크다운 파일만을 변환한다. `page.html` 파일은 마크다운 파일이 아니기에 마크다운 엔진은 이를 변환하지 않는다. 따라서 `page.html` 파일 안에 포함된 마크다운 구문(`_includes/markdown.md`의 내용)들은 렌더링되지 않는다.

include할 파일들은 되도록이면 HTML 문서로 만드는 것을 추천한다.

## 오류 시나리오 3 : 자바스크립트 구문 안에 Liquid를 사용하는 경우

다음과 같이 `page.html` 파일 안의 `<script>` 태그에 Liquid 구문을 사용하면 원하는 대로 작동하지 않는다.

{: .code-header}
page.html (Not working ver.)

{% highlight html %}
⋮
<p id="test"></p>

<script>
    {%- raw -%}
    {% assign sentence = "Hello World!" %}
    {% endraw %}

    document.getElementById("test").innerHTML = sentence;
</script>
⋮
{% endhighlight %}

Liquid는 빌드 시점에서만 사용된다. 브라우저에 실제로 HTML 문서가 로딩되는 런타임 시점에는 Liquid가 아무런 작용을 할 수 없다. 따라서 `sentence` 변수는 `undefined`가 된다.

이를 작동하게 하려면 다음과 같이 수정하면 된다.

{: .code-header}
page.html (Working ver.)

{% highlight html %}
⋮
<p id="test"></p>

<script>
    {%- raw -%}
    {% assign sentence = "Hello World!" %}
    {% endraw %}

    document.getElementById("test").innerHTML = {{ sentence }};
</script>
⋮
{% endhighlight %}

이렇게 하면 자바스크립트 입장에서는 Liquid의 `sentence` 변수의 값("Hello World!")가 하드코딩된 셈이 된다.